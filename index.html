<!DOCTYPE html>
<!-- This is based on DillingerLee's great template here:
https://github.com/Team-Code/KA_Offline -->
<html> 
 <head>
    <title>Game if you are bored</title> 
    <style>
        #header {
            border-bottom: 1px solid;
        	text-align: center;
        }
        #header:hover {
            background-color: gray;
        }
	a {
	    transition: transform .2s;
	}
	a:hover {
	    background-color:gray;
		transform: scale(1.2);
	}
	#prevlay {
	    text-align: center;
	}
	
    </style>
    <style>
	    /* Add a black background color to the top navigation */
		.topnav {
		  background-color: #333;
		  overflow: hidden;
		}

		/* Style the links inside the navigation bar */
		.topnav a {
		  float: left;
		  color: #f2f2f2;
		  text-align: center;
		  padding: 14px 16px;
		  text-decoration: none;
		  font-size: 17px;
		}

		/* Change the color of links on hover */
		.topnav a:hover {
		  background-color: #ddd;
		  color: black;
		}

		/* Add a color to the active/current link */
		.topnav a.active {
		  background-color: #4CAF50;
		  color: white;
		}
	 </style>
</head>
 <body>
    <div class="topnav">
	<a class="active" href="https://homebasedlearning.github.io">Normal version</a>
	<a href="https://homebasedlearning.github.io/hard">Hard version</a>
    </div>
	<!--Topnav credits to w3schools-->
    <p><span style = "color: red; font-weight: bold;">Pls click on the canvas to start the game.</span> Also the game is laggy. Btw I've been coding this game for a few days. I'm still actively adding levels to it. You can also 'inspect element' to see the game code (hopefully)</p>
	 <p style = "font-size: 2em; text-align: center; color: red; font-weight: bold;">Use ARROW KEYS to move, so you can't play this game if you are playing on a phone.</p>	 
    <p align="center"> 
	<!--This draws the Canvas on the webpage -->
      <canvas id="mycanvas"></canvas> 
    </p>
    <p>-Made by Javier</p>
    
    </body>
 
 <!-- Run all the JavaScript stuff -->
 <!-- Include the processing.js library -->
 <!-- See https://khanacademy.zendesk.com/hc/en-us/articles/202260404-What-parts-of-ProcessingJS-does-Khan-Academy-support- for differences -->
 
	
 <script src="https://cdn.jsdelivr.net/processing.js/1.4.8/processing.min.js"></script> 
 
 <script>
    var sketchProc = function(processingInstance) {
     with (processingInstance) {
        size(400, 400); 
        frameRate(60);





/* 
Use arrow keys to move

If you have seeen this before it is most likely on my alt account where I developed this game.

I made this game in less than a week so it's not perfect.

I will probably be adding more levels.

Don't leave tha game for too long if not oh noes will give ou an error message
*/






























/*
This game used Jacob's "Game Template" 
Jacob's "Game Template" can be found here:
https://www.khanacademy.org/computer-programming/game-template/4920704444923904
*/

//Some variables 
{
var playerSize = [20,20];//the size of the player
var pJumpHeight=8;
var playerColor = color(255,0,0);
var grid = 30;
var deaths = 0;
var eeTextEnabled = false;
var currentScene = 1;
}
/* 
These levels used Jacob's Platformer Editer v1.0 for the blocks that he provided
*/
/***********vvv ADD YOUR LEVELS HERE vvv***********/
var gamePlay = false;
var charStart = false;
var startStart = false;
var levels = [
    //Replace this with the code for your level.
    //You can add as many as you want. just put them one after the other.
       [
"                             ",
"                             ",
"                             ",
"                             ",
"                        %    ",
"           b                 ",
"           b                 ",
"   %     d b                 ",
" bbbbbbbbbbb                 ",
"           b                 ",
"           b         b       ",
"           b         b       ",
"   #    A  b         bbbb    ",
"                     b### b  ",
"            _ _ _ _  b###    ",
" P          ########Mb###@b  ",
"bbbbbbbbmmbbbbbbbbbbbbbbbbAAA",
"                             ",
],
    [
"                   ",
"                   ",
"                   ",
"                   ",
"                   ",
"                   ",
"                   ",
"   b               ",
"  b     &        b ",
" b  m   bbb__%   b ",
" bb              b ",
"    b            b ",
"    b##M##       b ",
"   b######AAAA@AAb ",
"   b##########b#b  ",
"  Pd############b##",
"bbbbbbbbbbbbbbbbbbbb",
"                    ",
],
[
"                   ",
"                   ",
"                   ",
"                   ",
"                   #",
"                   #",
"                   #",
"                   #",
"                   #",
"                   #",
"    o   m#b        #",
"    b   b#b        #",
"    b@  b bM_ _ _  #",
"    bbbbb%bb#b#b#b #",
"                  M#",
" Pdb&&&&&&&b% % %bb#",
"bbbbbbbbbbbbbbbbbbbb",
"                    ",
],
[
"                   ",
"                   ",
"                   ",
"#            b     ",
"#            b     ",
"#            b     ",
"#  bbbb      b     ",
"## %%%%b     b     ",
"###b   b     b & b ",
"###  b b     b     ",
"###@ b b     b & b ",
"#bob b b     b     ",
"##   bM      b & b ",
"##   bbob    b     ",
"##    bbbbb  b & b ",
"##Pd   ####  b     ",
"bbbbbbbbbbbAobbbbbbb",
"                    ",
],
[
"             #bdddd",
"  bb##b##b   #b    ",
"Pd  bb bb b  #b    ",
"b   ###    b #b    ",
"#   b   b    #b    ",
"#     bbbbbbb#b    ",
"# b bb       b#    ",
"# b#bb        @    ",
"#  b   bb#b##bbbbb ",
"#                  ",
"# bbbbbbb##b##b    ",
"#       bbbbbbb    ",
"#M      #          ",
"bbbbbbbb b b b     ",
"         b####     ",
"     A   b####ooooo",
"bbbbbbbbbbbbbbbbbbb",
"                   ",
],
[
"P_ _ _ _ _ _ _ _ _ _",
"b                   ",
"_ _ _ _ _ _ _ _ _ _ ",
"ddddddddddddddddd  d",
"                    ",
"                   d",
"_ _ _ _ _ _ _ _ _  d",
"d#ddddddddddddd  ddd",
"               _ _ _",
" odddddddddddd  MMMM",
"@                   ",
"b                  ",
"                   ",
"  b                ",
"                   ",
"AAAAAAAAAAAAAAAAAAA",
"bbbbbbbbbbbbbbbbbbbb",
"                    ",
],
[
"                   ",
"          s        ",
"          b        ",
"          b        ",
"          b        ",
"          b        ",
"          b dddddddd",
"        jbb        ",
"       M  b        ",
"          b _ _ _ _s",
"      M   b ########",
"    _    Mb ########",
"   b#     b ########",
"  sb#   M b ########",
"  b###    b ########",
" Pd####M  bjMMMM@MMM",
"bbbbbbbbbbbbbbbbbbbb",
"                    ",
],
[
"          b        ",
" oooooooo b        ",
"       b  b        ",
"       b bb        ",
"mmmmdm b  b        ",
"       bb b        ",
"       b  b        ",
" odoooob bb        ",
"       b    b      ",
"      @b           ",
"mmmmmdob n         ",
"            b      ",
"                   ",
"         g         ",
"  sbdbdb###########",
" Pd################",
"bbbbbbbbbbbbbbbbbbbb",
"                    ",
],
[
"                   ",
"                   ",
"                   ",
"                   ",
"                   ",
"                   ",
"                   ",
"                   ",
"                   ",
"                   ",
"                   ",
"                   ",
"                   ",
"                   ",
"              Pd   ",
"    @         mm   ",
"mmmmmmmmmmmmmbbbmmd",
"                   ",
],
[
"#                  ",
"#                  ",
"#       d#         ",
"#       dbbbbbbbbbbb",
"#       dM         ",
"#       dMbb#b#bb  b",
"#       dM  b b    ",
"#       dM#        ",
"#       dM#        ",
"#       dM#        ",
"#bc c cbdM#        ",
"#        M#@       ",
"#  _ _ _ Mbbmmmmmmm",
"b b######M         ",
"b b######M         ",
" Pd######M         ",
"bbbbbbbbbbbbbbbbbbb",
"                   ",
],
[
"                    ",
"bbbb                ",
"    bbbbbbbbbbbbbbbb",
"b  & & & & & & & & b",
" P#                 ",
"bbbbbbfbbbbbfbbbbb ",
"dddddddddddddddddd ",
"                    ",
"ffffffffffffffffffbb",
"ddd dddddddddddddddd",
"                    ",
" mmmmmffffbfoooooooo",
" bcdcddcb           ",
"        b           ",
"                   @",
"bbbbbbbbb   f   bmfb",
"dddddddddddddddddddd",
"                    ",
],
[
"                   ",
"                   ",
"                   ",
"                   ",
"                   ",
"           3       ",
"          b b      ",
"  b       b b      ",
"  b       b b      ",
"  b       b b      A",
"  b       b bbbbbbbb",
"  b       bccccccccb",
"  b       b        ",
"  b       bM       ",
"  b       bbbbbbbbbj",
"@ bP#M  I bO       2",
"bbbbbbbbbbbsbdbdbdbb",
"                    ",
],
[
"       dddd         ",
"      =c c =       ",
"           =  @    ",
"              b    ",
"                   ",
"       MMMM        ",
"    nbbbbbb        ",
"       bccb        ",
"    bbbb           ",
"  f ####++= O      ",
"ddojbbbbbbbdfddb   ",
"     b bb          ",
"      b++b         ",
"                   ",
"dPd          I     ",
"bbbbbbbMMdbbbb     ",
"#######bbbbbbbbbbo~m",
],
[
"d###########dbbbbbbbb     ",
"             bbbbbbbb     ",
"             b     bb    %",
"             b   @ bb    ",
"   MM MM MM  b bbbbbb  M ",
"   MM MM MM Pb         M%",
"  bbbbbbbbbbbbffffffff   ",
"             b########   M",
"_ _ _ _ _ _  b  M M  M M %",
"AAAAAAAAAAA  b     M     ",
"bbbbbbbbbbb  b M  M  M  M",
"%&&&%&&&%    b   M     ###",
"##           bM    M   ###",
"M    M  M    bAAAAAAA   ##",
"  bbbbbbbbbbbbbbbbbbbb   #",
"   %   %   %   %   %     ",
"           M     M       ",
"MM AAM  MA MAAM A  MAM MMM",
"bbbbbbbbbbbbbbbbbbbbbbbbbb",

],
[
    
"             bbbbbb% %b`````b bbbb",
"                            b% b @",
"                            b_ bMbb",
"                 b   &bbbbb b  &  b",
"                 b &  b   & b &   b",
"                 b   &b bbbbb     b",
"                 b &  b%   %b   _ b",
"###bbbbbbb####bbbb    b &   b     b",
"                 b  & b  &  b     b",
"  M    A      AA b&   b   & b _   b",
"   #  MAA    AAA b  & b  &  b     b",
"     # AAA  AAAA b    b &   b   _ b",
"       AA     AA b   &b&    b     b",
"       A      AA b    b &   b_    b",
"     M AAAA    A b &  b  &  b     b",
"    #  A  A   AA b&   b   & b   _ b",
" M     A      AA b    b    &b     b",
"  #    AA    AAA M    b   & b_    b",
"      MAAA  AAAA      b  &  b#    b",
"     # AAA  AAAA     Mb &###bb _  b",
" M   M A      AA  M   b& AAAbA    b",
"       A      AA      b  AAAbAM   b",
" M     AAAA  AAA     Mb    b b    b",
"  #    AAA  AAAA%     b   Mb b M  b",
"       A       AbAMAMAbbb  bbbbbb b",
"       AAAA    Ab     b b  b      ",
"       AAAA    Ab     b b  b     M",
" %%%  MAAAA      MAMAMbAAM b      ",
" %%%   AAAA           AAA  b MM   ",
" %P%   AAAA      AMAMAAAAM   MM  M",
"bbbbbbbbbbbbb##bbbbbbbbbbbbbbbbbbb ",
"             %                    ",
"             A                    ",
"             AA  A                ",
"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",

],
    
    ];
/******* vvv DON'T TOUCH THOSE! vvv ******/
var level = 0;
var keys = [];
var level_h = 800;
var level_w = 800;
var transparence = 0;
var redTrans = 0;
var cam;
//@key interaction
keyPressed = function(){keys[keyCode]=true;};
keyReleased = function(){ keys[keyCode]=false; };

var polygonCollide = function(shape1, shape2) {

    var isBetween = function(c, a, b) {
        return (a - c) * (b - c) <= 0;
    };
    
    /* Do ranges a and b overlap? */
    var overlap = function(a, b) {
        return isBetween(b.min, a.min, a.max) || isBetween(a.min, b.min, b.max);
    };
    
    /*
     * Project shape onto axis.  Simply
     * compute dot products between the
     * shape's vertices and the axis, and
     * keep track of the min and max values.
     */
    var project = function(shape, axis) {
        var mn = Infinity;
        var mx = -Infinity;
        for (var i = 0; i < shape.length; i++) {
            var dot = shape[i].x*axis.x + shape[i].y*axis.y;
            mx = max(mx, dot);
            mn = min(mn, dot);
        }
        return { min: mn, max: mx };
    };
    
    /* Compute all projections axes of shape. */
    var getAxes = function(shape) {
        var axes = [];
        for (var i = 0; i < shape.length; i++) {
            var n = (i + 1) % shape.length; 
            /*
             * The edge is simply the delta between i and n.
             * The axis is the edge's normal. And a normal 
             * of (x, y) is either of (y, -x) or (-y, x).
             */
            axes[i] = {
                y: shape[i].x - shape[n].x,
                x: -(shape[i].y - shape[n].y)
            };
        }
        return axes;
    };

    var shapes = [ shape1, shape2 ];
    for (var s = 0; s < shapes.length; s++) {
        var axes = getAxes(shapes[s]);
        for (var i = 0; i < axes.length; i++) {
            var axis = axes[i];
            /* Project both shapes onto this axis */
            var p1  = project(shape1, axis);
            var p2  = project(shape2, axis);
            if (! overlap(p1, p2)) {
                /* The two shapes cannot overlap */
                return false;
            }
        }
    }
    return true;  /* they overlap */
};//for triangular collisions


var Camera = function(x,y){
    this.x=x; this.y=y; this.w=width; this.h = height;
    this.view = function(plyer){
        this.x=plyer.x;
        this.y=plyer.y;
        
        this.x = constrain(this.x,this.w/2,level_w-this.w/2);
        this.y = constrain(this.y,this.h/2,level_h-this.h/2);
        translate(200-this.x,200-this.y);
    };
};

var view = function(obj){
    return obj.x+200-cam.x<width&&obj.x+200-cam.x>-obj.w&&
    obj.y+200-cam.y<height&&obj.y+200-cam.y>-obj.h;
};


var collide=function(obj1,obj2){ 
    return obj1.x<obj2.x+obj2.w&&obj1.x+obj1.w>obj2.x&& 
    obj1.y<obj2.y+obj2.h&&obj1.y+obj1.h>obj2.y;
};

var Button = function(x, y, w, h, label, size) {
    this.x = x; this.y = y; this.w = w; this.h = h;
    this.label = label;
    this.size = size;
};

Button.prototype.draw = function() {
    
    noStroke();
    fill(138, 138, 138);
    rectMode(CENTER);
    textAlign(CENTER);
    rect(this.x, this.y, this.w, this.h, 5);
    fill(0, 0, 0);
    textSize(this.size);
    text(this.label, this.x, this.y);
    rectMode(CORNER);
};

var button = [];
button.add = function(x, y, w, h, label) {this.push(new Button(x, y, w, h, label));};



var Player = function(x,y,w,h){
    this.x=x; this.y=y;
    this.w=w; this.h=h; 
    this.speed = 0.5;
    this.yvel = 0; this.xvel = 0;
    this.gravity = 0.3; this.JH = pJumpHeight;
    this.falling = false; this.speedLimit = 5;
    this.fallLimit = 8; this.health = 100;
    this.dir = 0; this.color = playerColor;//art stuff
    this.dead = false; this.deadTimer = 0; 
    this.stunned = false;
    this.update = function(blocks){
        this.sight = this.w/4;//calculate the offset of the face based on the width of the player.
        
        if(!this.dead && this.stunned === false){//moving
        if(keys[UP]&&!this.falling){ this.yvel=-this.JH;}
        if(keys[RIGHT]){this.xvel+=this.speed; this.dir+=this.speed;}
        if(keys[LEFT]){ this.xvel-=this.speed; this.dir-=this.speed;} 
        }
        if(!keys[RIGHT]&&!keys[LEFT]){
        if(this.dir>0){this.dir-=this.speed;}
        if(this.dir<0){this.dir+=this.speed;}
        if(this.xvel>0){this.xvel-=this.speed;}
        if(this.xvel<0){this.xvel+=this.speed;}
        }
        this.dir = constrain(this.dir,-this.sight,this.sight);
        this.xvel=constrain(this.xvel,-this.speedLimit,this.speedLimit);
        if(this.yvel>this.fallLimit){ this.yvel=this.fallLimit; }
        this.x = constrain(this.x,0,level_w-this.w);
        this.x+=this.xvel;
        this.applyCollision(blocks,this.xvel,0); // apply speed and collisions
        this.falling=true;
        this.y+=this.yvel;
        this.applyCollision(blocks,0,this.yvel);
        this.yvel+=this.gravity;
        
        if(this.health<=0){
            this.dead = true;
            eeTextEnabled = false;
        }
        if(this.dead){
            this.deadTimer++;
        }
        
    };
    this.draw = function() {
        noStroke();
        var d = (this.dir/this.w)*15;
    fill(this.color);
    rect(this.x,this.y,this.w,this.h,(this.w+this.h)/20);
    this.eyeSize = (this.w+this.h)/10;
    fill(0);
    ellipse(d+this.x+this.w/3,this.y+this.h/3,this.eyeSize,this.eyeSize);
    ellipse(d+this.x+this.w*2/3,this.y+this.h/3,this.eyeSize,this.eyeSize);

    noFill();
    stroke(0);
    strokeWeight(1);
    arc(d+this.x+this.w/2,this.y,this.w,this.h*1.5,70,110);
    };
    this.applyCollision=function(obj,velx,vely){
    for(var i=0; i<obj.length; i++){
        if(collide(this,obj[i])&&obj[i].solid){ // handle collisions
            if(obj[i].type==="ice"){obj[i].melting = true;}//make the ice blocks start melting
            if(obj[i].type==="fakeBlk"){obj[i].melting = true;}
            if(obj[i].type==="switchBlocks"){obj[i].melting = true;}
            if(vely>0){ this.yvel=0; this.falling=false; this.y=obj[i].y-this.h; }
            if(vely<0){ this.yvel=0; this.falling=true; this.y=obj[i].y+obj[i].h; }
            if(velx<0){ this.xvel=0; this.x=obj[i].x+obj[i].w; }
            if(velx>0){ this.xvel=0; this.x=obj[i].x-this.w; }
        }
    }
};
this.healthBar = function(){
    textSize(14);
    fill(255);
    rect(20,20,360,15);
    fill(255, 0, 0);
    rect(20,20,this.health * 3.6,15);
    fill(0);
    textAlign(CENTER,CENTER);
    text("Health "+max(0,round(this.health))+"%",208,20+15/2);
    this.health = constrain(this.health,0,100);
};
};
var player = new Player(200,100,playerSize[0],playerSize[1]);

/*
var Characters = function(x, y, w, h, design) {
    this.design = design;
    this.color = playerColor;
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
};
Characters.prototype.draw = function() {
    if(this.design === "classic") {
        noStroke();
        var d = (this.dir/this.w)*15;
        fill(this.color);
        rect(this.x,this.y,this.w,this.h,(this.w+this.h)/20);
        this.eyeSize = (this.w+this.h)/10;
        fill(0);
        ellipse(d+this.x+this.w/3,this.y+this.h/3,this.eyeSize,this.eyeSize);
        ellipse(d+this.x+this.w*2/3,this.y+this.h/3,this.eyeSize,this.eyeSize);
    
        noFill();
        stroke(0);
        strokeWeight(1);
        arc(d+this.x+this.w/2,this.y,this.w,this.h*1.5,70,110);
    }
    if(this.design === "rainbow") {
        noStroke();
        var d = (this.dir/this.w)*15;
        for (var i = 0; i < 10; i++) {
            playerColor = color(i * 10, 0, 0);
        }
        fill(this.color);
        rect(this.x,this.y,this.w,this.h,(this.w+this.h)/20);
        this.eyeSize = (this.w+this.h)/10;
        fill(0);
        ellipse(d+this.x+this.w/3,this.y+this.h/3,this.eyeSize,this.eyeSize);
        ellipse(d+this.x+this.w*2/3,this.y+this.h/3,this.eyeSize,this.eyeSize);
    
        noFill();
        stroke(0);
        strokeWeight(1);
        arc(d+this.x+this.w/2,this.y,this.w,this.h*1.5,70,110);
    }
};
var characters = [];
characters.add = function(x, y, w, h, design) {this.push(new Character(x, y, w, h, design));};
*/



//@blocks
var Block = function(x,y,w,h,type,i){
    this.x=x; this.y=y; this.w=w; this.h=h; this.isImage = i;
    this.type = type; this.melting = false;
    this.solid = true; this.op = 255;
    this.fast = false; this.idk = 255;
    this.oppFast = false;
    this.slow = false;
    this.r = 163; this.g = 163; this.b = 163;
    this.draw = function() {
        if(view(this)){
            switch(this.type){
                case "moving":
                    noStroke();
                    fill(77, 77, 77);
                    rect(this.x, this.y, this.w, this.h);
                    fill(163, 163, 163);
                    pushMatrix();
                    translate(18, 16);
                    triangle(this.x - 10, this.y + 10, this.x - 10, this.y - 10, this.x + 10, this.y);   
                    popMatrix();
                break;
                case "op-moving":
                    noStroke();
                    fill(77, 77, 77);
                    rect(this.x, this.y, this.w, this.h);
                    fill(163, 163, 163);
                    pushMatrix();
                    translate(13, 16);
                    triangle(this.x - 10, this.y + 0, this.x + 10, this.y - 10, this.x + 10, this.y + 10);   
                    popMatrix();
                break;
                case "solid":
                    noStroke(); fill(163, 163, 163);
                    rect(this.x,this.y,this.w,this.h);
                break;
                case "ice":
                    strokeWeight(2); stroke(255,255,255,this.op); fill(150, 207, 245,this.op);
                    rect(this.x+1,this.y+1,this.w-2,this.h-2);
                break;
                case "slow":
                    noStroke(); fill(222, 206, 57);
                    rect(this.x, this.y, this.w, this.h);
                break;
                case "jumpy":
                    noStroke(); fill(68, 255, 51);
                    rect(this.x, this.y, this.w, this.h);
                break;
                case "easterEggJumpy":
                    noStroke(); fill(68, 255, 51);
                    rect(this.x, this.y, this.w, this.h);
                break;
                case "gravity":
                    noStroke(); fill(255, 119, 0);
                    rect(this.x, this.y, this.w, this.h);
                break;
                case "normal-grav":
                    noStroke(); fill(0, 60, 255);
                    rect(this.x, this.y, this.w, this.h);
                break;
                case "fakeBlk":
                    noStroke(); fill(this.r, this.g, this.b, this.op);
                    rect(this.x, this.y, this.w, this.h);
                break;
                case "mobBlk":
                    noStroke(); fill(200, 200, 200);
                    rect(this.x, this.y, this.w, this.h);
                break;
                case "easterEgg":
                    noStroke(); fill(163, 163, 163);
                    rect(this.x, this.y, this.w, this.h);
                break;
            }
        }
    };
    this.update = function(){
        if(this.type==="ice"){
            if(this.melting){
                this.op-=50;
            }
            if(this.op<50){
                this.solid = false;
            }
            if(this.op<-2000){
                this.op=255;
                this.melting = false;
                this.solid = true;
            }
            
        }
       if (this.type === "moving") {
            
            if (player.x <= this.x + this.w && player.x >= this.x - (this.w / 2) && player.y <= this.y && (player.y + playerSize[1]) >= this.y) {
                    this.fast = true;    
            }
            else {
                this.fast = false;   
            }
            if (this.fast === true) {
                player.x += 5;
            }
            if (this.idk === 255) {
                this.fast = false;    
            }
            
            
        }
        if (this.type === "op-moving") {
            
            if (player.x <= this.x + this.w && player.x >= this.x - (this.w / 2) && player.y <= this.y && (player.y + playerSize[1]) >= this.y) {
                    this.oppFast = true;    
            }
            else {
                this.oppFast = false;   
            }
            if (this.oppFast === true) {
                player.x -= 5;
            }
            if (this.idk === 255) {
                this.oppFast = false;    
            }
            
            
        }
        if (this.type === "slow") {
            if (player.x <= this.x + this.w && player.x >= this.x - (this.w / 2) && player.y <= this.y && (player.y + playerSize[1]) >= this.y) {
                player.gravity = 1;
            }
            
        }
        if (this.type === "jumpy") {
            if (player.x <= this.x + this.w && player.x >= this.x - (this.w / 2) && player.y <= this.y && (player.y + playerSize[1]) >= this.y) {
                player.gravity = 0.15;
            }    
        }
        if (this.type === "easterEggJumpy") {
            if (player.x <= this.x + this.w && player.x >= this.x - (this.w / 2) && player.y <= this.y && (player.y + playerSize[1]) >= this.y) {
                player.gravity = 0.15;
                
            }    
        }
        if (this.type === "gravity") {
            if (player.x <= this.x + this.w && player.x >= this.x - (this.w / 2) && player.y <= this.y && (player.y + playerSize[1]) >= this.y) {
                player.gravity = 0.56;
            }    
        }
        if (this.type === "normal-grav") {
            if (player.x <= this.x + this.w && player.x >= this.x - (this.w / 2) && player.y <= this.y && (player.y + playerSize[1]) >= this.y) {
                player.gravity = 0.3;
            }    
        }
        if(this.type==="fakeBlk"){
            if(this.melting){
                this.r = 255; this.g = 0; this.b = 0;
                this.op-=20;
            }
            if(this.op<50){
                this.solid = false;
            }
            if(this.op<-2000){
                this.op=255;
                this.melting = false;
                this.solid = true;
                this.r = 163; this.g = 163; this.b = 163;
            }
            
        }
        if(this.type === "mobBlk") {
            this.solid = false;
        }
        
        
    };
    
};
var blocks = [];
blocks.add = function(x,y,w,h,t){ this.push(new Block(x,y,w,h,t)); };
blocks.apply = function(){
    for(var i=0;i<this.length;i++){
        this[i].draw();
        this[i].update();
    }
};


var TeleporterIn = function(x, y, w, h) {
    this.x = x; this.y = y;  this.w = w; this.h = h;
    this.complete = false; this.isOff = false;
    this.draw = function() {
        noStroke();
        fill(0, 0, 0);
        rect(this.x, this.y + grid, this.w, 5);
        fill(0, 34, 255, 100);
        quad(this.x, this.y + grid, this.x + this.w, this.y + grid, this.x + this.w + 10, this.y + 10, this.x - 10, this.y + 10);
    };
    this.update = function() {
        if (!collide(this, player)) {
            this.isOff = true;
        }
        if (collide(this, player) && this.isOff === true) {
            this.complete = true;
        }    
    };
};
var teleporterIns = [];
teleporterIns.add = function(x,y,w,h){this.push(new TeleporterIn(x,y,w,h));};
teleporterIns.apply = function(){
    for(var i=0;i<this.length;i++){
        this[i].draw();
        this[i].update();
    }
};

var TeleporterOut = function(x, y, w, h) {
    this.x = x; this.y = y;  this.w = w; this.h = h;
    this.complete = false; this.isOff = false;
    this.draw = function() {
        noStroke();
        fill(0, 0, 0);
        rect(this.x, this.y + grid, this.w, 5);
        fill(0, 34, 255, 50);
        quad(this.x, this.y + grid, this.x + this.w, this.y + grid, this.x + this.w + 10, this.y + 10, this.x - 10, this.y + 10);
    };
    this.update = function() {
        if (!collide(this, player)) {
            this.isOff = true;
        }
        if (collide(this, player) && this.isOff === true) {
            this.complete = true;
        }    
    };
};
var teleporterOuts = [];
teleporterOuts.add = function(x,y,w,h){this.push(new TeleporterOut(x,y,w,h));};
teleporterOuts.apply = function(){
    for(var i=0;i<this.length;i++){
        this[i].draw();
        this[i].update();
    }
};


var TeleporterIn2 = function(x, y, w, h) {
    this.x = x; this.y = y;  this.w = w; this.h = h;
    this.complete = false; this.isOff = false;
    this.draw = function() {
        noStroke();
        fill(0, 0, 0);
        rect(this.x, this.y + grid, this.w, 5);
        fill(255, 34, 255, 100);
        quad(this.x, this.y + grid, this.x + this.w, this.y + grid, this.x + this.w + 10, this.y + 10, this.x - 10, this.y + 10);
    };
    this.update = function() {
        if (!collide(this, player)) {
            this.isOff = true;
        }
        if (collide(this, player) && this.isOff === true) {
            this.complete = true;
        }    
    };
};
var teleporterIns2 = [];
teleporterIns2.add = function(x,y,w,h){this.push(new TeleporterIn2(x,y,w,h));};
teleporterIns2.apply = function(){
    for(var i=0;i<this.length;i++){
        this[i].draw();
        this[i].update();
    }
};

var TeleporterOut2 = function(x, y, w, h) {
    this.x = x; this.y = y;  this.w = w; this.h = h;
    this.complete = false; this.isOff = false;
    this.draw = function() {
        noStroke();
        fill(0, 0, 0);
        rect(this.x, this.y + grid, this.w, 5);
        fill(255, 34, 255, 50);
        quad(this.x, this.y + grid, this.x + this.w, this.y + grid, this.x + this.w + 10, this.y + 10, this.x - 10, this.y + 10);
    };
    this.update = function() {
        if (!collide(this, player)) {
            this.isOff = true;
        }
        if (collide(this, player) && this.isOff === true) {
            this.complete = true;
        }    
    };
};
var teleporterOuts2 = [];
teleporterOuts2.add = function(x,y,w,h){this.push(new TeleporterOut2(x,y,w,h));};
teleporterOuts2.apply = function(){
    for(var i=0;i<this.length;i++){
        this[i].draw();
        this[i].update();
    }
};
//@portal
var Goal = function(x,y,radius,i){
    this.x=x; this.y=y; this.w=radius; this.h=radius; this.isImage = i;
    this.timer = 0; this.complete = false; this.color = 0;
    this.draw = function() {
        if(view(this)){
            colorMode(HSB);
            noStroke();
            for(var i=0;i<this.w/2;i+=2){
            fill(255,0,255,i*10);
        ellipse(this.x+this.w/2,this.y+this.h/2,this.w-i*2,this.h-i*2);
        }
        noFill();
        strokeWeight(2);
        for(var i=0;i<this.w/2;i+=2){
            this.opacity = (sin(i*frameCount)*70);
            stroke(frameCount%255, 255,255,this.opacity);
        ellipse(this.x+this.w/2,this.y+this.h/2,this.w-i*2,this.h-i*2);
        }
        colorMode(RGB);
        }
    };
    this.update = function(){
        
        if(collide(this,player)){
            transparence+=5;
        }
        if(transparence>=250){
            this.complete = true;
        }
        
    };
};
var portals = [];
portals.add=function(x,y,r){ this.push( new Goal(x,y,r));};
portals.apply = function(){
    for(var i=0;i<this.length;i++){
        this[i].draw();
        this[i].update();
    }
};

//@lava
var Lava = function(x,y,s,i){
    this.x=x; this.y=y; this.w=s; this.h=s;
    this.s = (s/3); this.isImage = i;
    this.draw = function() {
        if(view(this)){
        noStroke();
        for(var x=0;x<this.w;x+=this.s){
            for(var y=0;y<this.h;y+=this.s){
                fill(random(100,200),0,0);
                rect(this.x+x,this.y+y,this.s,this.s);
            }
        }
        }
    };
    this.update = function(){
        if(collide(this,player)){
            player.health-=2;
            redTrans = 80;
            
        }
    };
};
var lava = [];
lava.add = function(x,y,s){ this.push(new Lava(x,y,s)); };
lava.apply = function(){
    for(var i=0;i<this.length;i++){
        this[i].draw();
        this[i].update();
    }};
//@deathBlock
var deathBlock = function(x,y,s,i){
    this.x=x; this.y=y; this.w=s; this.h=s;
    this.s = (s/3); this.isImage = i;
    this.draw = function() {
        if(view(this)){
        noStroke();
        for(var x=0;x<this.w;x+=this.s){
            for(var y=0;y<this.h;y+=this.s){
                fill(random(0, 69), random(0, 69), random(0, 69));
                rect(this.x+x,this.y+y,this.s,this.s);
            }
        }
        }
    };
    this.update = function(){
        if(collide(this,player)){
            player.health = 0;
            redTrans = 80;
            
        }
    };
};
var DeathBlock = [];
DeathBlock.add = function(x,y,s){ this.push(new deathBlock(x,y,s)); };
DeathBlock.apply = function(){
    for(var i=0;i<this.length;i++){
        this[i].draw();
        this[i].update();
    }};
    
var Switch = function(x, y, type) {
    this.x = x;this.y = y; this.h = grid / 5 * 3; this.w = this.h;
    this.redOpen = false; this.blueOpen = false;
    this.draw = function() {
        if(view(this)){
            switch(this.type){
                case "red":
                    fill(0);
                    rect(this.x, this.y, this.w, this.h);
                    fill(255);
                    ellipse(this.x, this.y, this.w / 2 * 3, this.h / 2 * 3);
                break;
                case "blue":
                    fill(0);
                    rect(this.x, this.y, this.w, this.h);
                    fill(0, 0, 255);
                    ellipse(this.x, this.y, this.w / 2 * 3, this.h / 2 * 3);
                break;
            }
        }
    };
    this.update = function() {
        if (this.type === "red") {
            if(collide(this, player)) {
                this.redOpen = true;
            }
        }
        if (this.type === "blue") {
            if(collide(this, player)) {
                this.blueOpen = true;
            }
        }
    };
};
var switches = [];
switches.add = function(x,y,s){ this.push(new Switch(x,y,s)); };
switches.apply = function(){
    for(var i=0;i<this.length;i++){
        this[i].draw();
        this[i].update();
    }};
    
var SwitchBlock = function(x, y, w, h, type) {
    this.x = x; this.y = y; this.w = w; this.h = h;
    this.melting = false; this.solid = true;
    this.redStart = false; this.blueStart = false;
    this.draw = function() {
        if(view(this)){
            switch(this.type){
                case "red":
                    fill(255, 0, 0, 100);
                    fill(0, 0, 0);
                    rect(this.x, this.y, this.w, this.h);
                break;
                case "blue":
                    fill(0, 0, 255, 100);
                    rect(this.x, this.y, this.w, this.h);
                break;
            }
        }
    };
    this.update = function() {
        if(this.type === "red") {
            this.redStart = true;
        }
        if(this.type === "blue") {
            this.blueStart = true;
        }
        
    };
};
var switchBlocks = [];
switchBlocks.add = function(x,y,w,h,type){ this.push(new SwitchBlock(x,y,w,h,type)); };
switchBlocks.apply = function(){
    for(var i=0;i<this.length;i++){
        this[i].draw();
        this[i].update();
    }
};
//@ghostBlock
var ghostBlock = function(x,y,s,i){
    this.x=x; this.y=y; this.w=s; this.h=s;
    this.s=s; this.isImage = i;
    this.draw = function() {
        if(view(this)){
        noStroke();
        for(var x=0;x<this.w;x+=this.s){
            for(var y=0;y<this.h;y+=this.s){
                fill(209, 209, 209);
                rect(this.x+x,this.y+y,this.s,this.s);
            }
        }
        }
    };
    
};
var GhostBlock = [];
GhostBlock.add = function(x,y,s){ this.push(new ghostBlock(x,y,s)); };
GhostBlock.apply = function(){
    for(var i=0;i<this.length;i++){
        this[i].draw();
    }};
//@spikes
var Spike = function(x,y,w,h,i){
    this.x=x; this.y=y; this.w=w; this.h=h;
    this.isImage = i;
    this.draw = function() {
        if(view(this)){
            noStroke();
        fill(120);
        triangle(this.x+this.w/2,this.y,this.x,this.y+this.h,this.x+this.w,this.y+this.h);
        }
        
        
    };
    this.update = function(){
        if(polygonCollide([
            {x:player.x,y:player.y},
            {x:player.x+player.w,y:player.y},
            {x:player.x+player.w,y:player.y+player.h},
            {x:player.x,y:player.y+player.h}],//the player
            [{x:this.x+this.w/2,y:this.y},
            {x:this.x,y:this.y+this.h},
            {x:this.x+this.w,y:this.y+this.h}])){
        player.yvel=-player.JH;
        player.health-=5;
        redTrans = 80;//red flash
        }
    };
    
};
var spikes = [];
spikes.add=function(x,y,s){ this.push( new Spike(x,y,s,s)); };
spikes.apply = function(){
    for(var i=0;i<spikes.length;i++){
        this[i].draw();
        this[i].update();
    }
};

//@jumpBlocks
var JumpBlock = function(x,y,w,h,i){
    this.x=x; this.y=y; this.w=w; this.h=h; this.isImage = i;
    this.draw = function() {
        if(view(this)){
            noStroke();
            fill(255, 71, 169);
            rect(this.x,this.y,this.w,this.h);
        }
    };
    this.update = function(){
        if(collide(this,player)){
            player.yvel=-player.JH*1.3;
        }
        
    };
    
};
var jumpBlocks = [];
jumpBlocks.add = function(x,y,w,h){ this.push( new JumpBlock(x,y,w,h) );  };
jumpBlocks.apply = function(){
    for(var i=0;i<this.length;i++){
        this[i].draw();
        this[i].update();
    }
};
    
var Bullet = function(x,y,s,angle){
    this.x=x; this.y=y; this.w=s; this.h=s;
    this.deleted = false; this.angle = angle;
    this.draw = function() {
        if(!this.deleted){
        noStroke();
        fill(50);
        ellipseMode(CORNER);
        ellipse(this.x,this.y,this.w,this.h);
        ellipseMode(CENTER);
        }
    };
    this.update = function(){
        this.x+=cos(this.angle)*2;
        this.y+=sin(this.angle)*2;
        if(collide(this,player)&&!this.deleted&&!player.dead){
            this.deleted = true;
            player.health -=10;
            redTrans=80;
        }
        for(var i=0;i<blocks.length;i++){
        if(collide(this,blocks[i])&&!this.deleted){
            this.deleted = true;
        }
        }
        
    };
};
var bullets = [];
bullets.add = function(x,y,angle){
    this.push( new Bullet(x,y,5,angle));
};
bullets.apply = function(){
    for(var i=0;i<this.length;i++){
        bullets[i].draw();
        bullets[i].update();
        if(bullets[i].deleted){
            bullets.splice(i,1);
        }
    }
};

var Cannon = function(x,y,w,h){
    this.x=x; this.y=y; this.w=w; this.h=h;
    this.angle = atan2(this.x-player.x,player.y-this.y);
    this.bullets = [];
    this.draw = function() {
        if(view(this)){
        noStroke();
        fill(80);
        ellipse(this.x+this.w/2,this.y+this.h/2,this.w*3/5,this.h*3/5);
        pushMatrix();
        translate(this.x+this.w/2,this.y+this.h/2);
        rotate(this.angle);
        rect(-5,5,this.w/3,10);
        popMatrix();
        }
        
    };
    this.update = function(){
        this.angle = atan2(this.x-player.x,player.y-this.y);
        if((frameCount%100)===99){
            bullets.add(this.x+this.w/2,this.y+this.h/2,this.angle+90);
        }
        
    };
    
};
var cannons = [];
cannons.add = function(x,y,s){this.push( new Cannon(x,y,s,s));};
cannons.apply = function(){
    for(var i=0;i<this.length;i++){
        this[i].draw();
        this[i].update();
    }
};

var Monster=function(x,y,w,h){
    this.x=x; this.y=y; this.w=w; this.h=h;
    this.dead=false; // is the monster "dead"?
    this.xvel=1; // monster's speed
    this.angle=0; // the monster's eye's angle
this.draw= function() {
    if(view(this)&&!this.dead){
        // draw the monster
        fill(23, 130, 57);
        noStroke();
        rect(this.x,this.y,this.w,this.h,Math.abs(cos(frameCount*2))*10); // main body
        
        fill(255, 255, 255);
        stroke(0);
        ellipse(this.x+this.w/2,this.y+this.h/2,this.w/2,this.h/2); // the white of the eye
        // the pupil
        pushMatrix();
        translate(this.x+this.w/2,this.y+this.h/2);
        rotate(this.angle+40);
        fill(0, 0, 0);
        ellipseMode(CORNER);
        ellipse(0,0,this.w/5,this.h/5);
        ellipseMode(CENTER);
        popMatrix();
    }
};
this.update = function(){
    if(!this.dead){
    this.angle = atan2(this.x-player.x,player.y-this.y);//make the angle point to the player
    this.x+=this.xvel;
    for(var i=0;i<blocks.length;i++){
        if(collide(this, blocks[i])){
            this.xvel=-this.xvel;
        }
    }
    if(collide(this, player)){
        if(!player.falling&&!this.dead&&!player.dead){
                player.health-=5;
                redTrans = 80;
        }else if(player.yvel>0&&player.falling){
                this.dead=true; // the monster is "dead"
                player.yvel=-player.JH; // make the player hop 
                
            }
    }
    }
};
};
var monsters=[];
monsters.add=function(x,y,w,h){ this.push(new Monster(x,y,w,h)); };
monsters.apply=function(){
    for(var i=0; i<this.length; i++){
        this[i].update();
        this[i].draw();
        if(this[i].dead){this.splice(i,1);}
    }
};







var Predator=function(x,y,w,h){
    this.x=x; this.y=y; this.w=w; this.h=h;
    this.dead=false; // is the predator "dead"?
    this.xvel=1; //predator's speed
    this.angle=0; // the predator's eye's angle
    this.stunTimer = 0;
    this.stunTimerStart = false;
this.draw= function() {
    if(view(this)&&!this.dead){
        // draw the predator
        fill(255, 110, 110, 100);
        noStroke();
        rect(this.x,this.y,this.w,this.h); // main body
        
        if (this.xvel > 0) {
            fill(135, 19, 19);
            triangle(this.x + this.w, this.y + (this.h / 4), this.x + (this.w / 2), this.y + (this.h / 2), this.x + this.w, this.y + (this.h / 4 * 3));
        }
        if (this.xvel < 0) {
            fill(135, 19, 19);
            triangle(this.x, this.y + (this.h / 4), this.x + (this.w / 2), this.y + (this.h / 2), this.x, this.y + (this.h / 4 * 3));
        }
        
        
        /*
        fill(255, 255, 255);
        stroke(0);
        ellipse(this.x+this.w/2,this.y+this.h/2,this.w/2,this.h/2); // the white of the eye
        // the pupil
        pushMatrix();
        translate(this.x+this.w/2,this.y+this.h/2);
        rotate(this.angle+40);
        fill(0, 0, 0);
        ellipseMode(CORNER);
        ellipse(0,0,this.w/5,this.h/5);
        ellipseMode(CENTER);
        popMatrix();
        */
    }
};
this.update = function(){
    if(!this.dead){
        this.angle = atan2(this.x-player.x,player.y-this.y);//make the angle point to the player
        this.x+=this.xvel;
        for(var i=0;i<blocks.length;i++){
            if(collide(this, blocks[i])){
                this.xvel=-this.xvel;
            }
        }
        for(var i=0;i<lava.length;i++){
            if(collide(this, lava[i])){
                this.xvel=-this.xvel;
            }
        }
        if(collide(this, player)){
            if(!player.falling&&!this.dead&&!player.dead){
                    this.stunTimerStart = true;
                    redTrans = 80;
            }else if(player.yvel>0&&player.falling){
                    this.dead=true; // the predator is "dead"
                    player.yvel=-player.JH; // make the player hop 
                    
            }
        }
    }
        if(this.stunTimerStart === true) {
                this.stunTimer++;
        }
        if(this.stunTimer > 0 && this.stunTimer <= 180) {
                player.stunned = true;
        }
        if(this.stunTimer > 180 || this.stunTimer ===0) {
                this.stunTimerStart = false;
                this.stunTimer = 0;
                player.stunned = false;
                
                    
        }
        
    
    
};

};
var predators=[];
predators.add=function(x,y,w,h){ this.push(new Predator(x,y,w,h)); };
predators.apply=function(){
    for(var i=0; i<this.length; i++){
        this[i].update();
        this[i].draw();
        if(this[i].dead){this.splice(i,1);}
    }
};









var moveCannon = function(x,y,w,h){
    this.x=x; this.y=y; this.w=w; this.h=h;
    this.angle = atan2(this.x-player.x,player.y-this.y);
    this.bullets = []; this.dead = false;
    this.xvel = 1;
    this.draw = function() {
        if(view(this)){
        noStroke();
        fill(80);
        ellipse(this.x+this.w/2,this.y+this.h/2,this.w*3/5,this.h*3/5);
        pushMatrix();
        translate(this.x+this.w/2,this.y+this.h/2);
        rotate(this.angle);
        rect(-5,5,this.w/3,10);
        popMatrix();
        }
        
    };
    this.update = function(){
        this.angle = atan2(this.x-player.x,player.y-this.y);
        if((frameCount%100)===99){
            bullets.add(this.x+this.w/2,this.y+this.h/2,this.angle+90);
        }
        if (!this.dead) {
            this.x += this.xvel;
            
            for(var i=0;i<blocks.length;i++){
                if(collide(this, blocks[i])){
                    this.xvel=-this.xvel;
                }
            }
            if(collide(this, player)){
                if(!player.falling&&!this.dead&&!player.dead){
                        player.health-=5;
                        redTrans = 80;
                }else if(player.yvel>0&&player.falling){
                        this.dead=true; // the monster is "dead"
                        player.yvel=-player.JH; // make the player hop 
                        
                }
            }
        }
    };
    
};
var moveCannons = [];
moveCannons.add = function(x,y,s){this.push( new moveCannon(x,y,s,s));};
moveCannons.apply = function(){
    for(var i=0;i<this.length;i++){
        this[i].draw();
        this[i].update();
        if(this[i].dead){this.splice(i,1);}
    }
};
    
//manage the objects in the game
var objects = [blocks,portals,lava,spikes,jumpBlocks,cannons,bullets, monsters, DeathBlock, GhostBlock, moveCannons, teleporterIns, teleporterOuts, teleporterIns2, teleporterOuts2, switches, switchBlocks, predators];
objects.remove = function(){
    for (var i = 0; i < objects.length; i++) {
        for (var j = 0; j < objects[i].length; j++) {
            objects[i].splice(j, objects[i].length);
        }
    }
};

var updateMap = function(){
    objects.remove();
    for(var col=0; col<levels[level].length; col++){
        var cells = levels[level][col];
        for(var row=0; row<cells.length; row++){
            switch(cells[row]){
                case "b": blocks.add(row*grid,col*grid,grid,grid,"solid",player);
                    break;
                case "@": portals.add(row*grid,col*grid,grid);
                    break;
                case "_": blocks.add(row*grid,col*grid+(grid/3)*2,grid*2,grid/3,"ice");
                    break;
                case "#": lava.add(row*grid,col*grid,grid,grid);
                    break;
                case "P": player = new Player(row*grid-(player.w-grid)/2,col*grid-(player.h-grid)/2,playerSize[0],playerSize[1]);
                    break;
                case "A": spikes.add(row*grid,col*grid,grid,grid);
                    break;
                case "M": jumpBlocks.add(row*grid,col*grid+grid*2/3,grid,grid/3);
                    break;
                case "%": cannons.add(row*grid,col*grid,grid);
                    break;
                case "&": monsters.add(row*grid,col*grid,grid,grid);
                    break;
                case "m": blocks.add(row * grid,col * grid, grid, grid, "moving");
                    break;
                case "d": DeathBlock.add(row * grid, col * grid, grid, grid);
                    break;
                case "o": blocks.add(row * grid, col * grid, grid, grid, "op-moving");
                    break;
                case "s": blocks.add(row * grid, col * grid, grid, grid, "slow");
                    break;
                case "j": blocks.add(row * grid, col * grid, grid, grid, "jumpy");
                    break;
                case "g": blocks.add(row * grid, col * grid, grid, grid, "gravity");
                    break; 
                case "n": blocks.add(row * grid, col * grid, grid, grid, "normal-grav");
                    break; 
                case "c": moveCannons.add(row*grid,col*grid,grid);
                    break;
                case "G": GhostBlock.add(row * grid, col * grid, grid);
                    break;
                case "f": blocks.add(row * grid, col * grid, grid, grid, "fakeBlk");
                    break;
                case "I": teleporterIns.add(row * grid, col * grid, grid, grid);
                    break;
                case "O": teleporterOuts.add(row * grid, col * grid, grid, grid);
                    break;
                case "2": teleporterIns2.add(row * grid, col * grid, grid, grid);
                    break;
                case "3": teleporterOuts2.add(row * grid, col * grid, grid, grid);
                    break;
                case "R": switches.add(row * grid, col * grid, "red");
                    break;
                case "B": switches.add(row * grid, col * grid, "blue");
                    break;
                case "r": switchBlocks.add(row * grid, col * grid, grid, grid, "red");
                    break;
                case "S": switchBlocks.add(row * grid, col * grid, grid, grid, "blue");
                    break;
                case "+": predators.add(row*grid,col*grid,grid,grid);
                    break;
                case "=": blocks.add(row * grid, col * grid, grid, grid, "mobBlk");
                    break;
                case "~": blocks.add(row * grid, col * grid, grid, grid, "easterEggJumpy");
                    break;
                case "`": blocks.add(row * grid, col * grid, grid, grid, "easterEgg");
                    break;
            }
            level_w = levels[level][col].length * grid;
            level_h = levels[level].length * grid;
        }
    }
};

    
var resetCam = function(){
cam.x=player.x; cam.y=player.y;
};//reset the cam to the player's location.
var applyGame = function(){
    blocks.apply();
    portals.apply();
    if(!player.dead){ player.draw(); }
    lava.apply();
    spikes.apply();
    jumpBlocks.apply();
    monsters.apply();
    bullets.apply();
    cannons.apply();
    DeathBlock.apply();
    moveCannons.apply();
    GhostBlock.apply();
    teleporterIns.apply();
    teleporterOuts.apply();
    teleporterIns2.apply();
    teleporterOuts2.apply();
    predators.apply();
    player.update(blocks);
    
    
};
    
var startButton = new Button(200, 100, 200, 100, "Start", 30);
var charButton = new Button(200, 300, 200, 100, "Choose \nCharacter", 30);
var backButton = new Button(30, height - 15, 50, 25, "Go Back", 10);
//var rainbowC = new Character(100, 200, player.w, player.h, "rainbow");

var drawGameScene = function() {
    currentScene = 3;
    var timer = floor(frameCount / 60);
    background(200);
    pushMatrix();
    cam.view(player);
    textSize(20);
    if (level === 0) {
        fill(0, 0, 0);
        textSize(20);
        text("This is ice, \nit melts really fast.\n\t ", 450, 361 - grid);
        text("This is a trampoline, \nit makes you bounce.\n\t ", 606, 276 - grid);
        text("This is a \n spike, \ndo not touch.\n\t     ", 239, 315 - grid);
        text("This is lava, \ndo not touch.\n\t ", 100, 325 - grid);
        textSize(10);
        text("This is death, \ndo not touch.\n\t ", 280, 215 - grid);
        text("This is a cannon, \nshoots dangerous stuff.\n\t ", 100, 217 - grid);
        textSize(15);
        text("This block makes you \nmove in the \ndirection it is facing\n", 264, 443 - grid);
    }
    if(level === 3) {
        fill(0, 0, 0);
        textSize(15);
        text("Sometimes \nyou\n just have to \nrisk it...", 107, 416 - grid);
        textSize(26);
        textSize(15);
        fill(150, 150, 150);
        text("Dash!!", 182, 497 - grid);
    }
    if (level === 6) {
        fill(140, 127, 51);
        text("Yellow honey blocks \nsimulate \nsun gravity", 105, 296 - grid);
        fill(13, 97, 4);
        text("Green jump boost blocks \nsimulate \nmoon gravity", 152, 200 - grid);
    }
    if (level === 7) {
        fill(0, 0, 0);
        text("More gravity\n blocks added", 188, 372 - grid);
    }
    if (level === 8) {
        fill(0, 0, 0);
        text("Free level!!!", 470, 372 - grid);
    }
    if (level === 9) {
        fill(0, 0, 0);
        text("Yay! \nI made \nmoving cannons!", 136, 248 - grid);
    }
    if (level === 10) {
        fill(0, 0, 0);
        text("Fake blocks are involved...", 258, 131 - grid);
    }
    if (level === 11) {
        fill(0);
        textSize(39);
        text("Portals!!", 200, 393 - grid);
    }
    if(level === 12) {
        fill(0);
        textSize(15);
        text("This is a fan-suggested level", 230, 410);
        text("Level suggested by: Anonymous", 230, 400 + grid);
        text("Predators stun you \nwhen you collide \nwith them", 400, 250 - grid);
        text("Predators \nstun you \nwhen you collide \nwith them", 60, 225 - grid);
    }
    
    
    applyGame();
    popMatrix();
    player.healthBar();
    if(player.deadTimer>100){updateMap(); resetCam();}
    if(portals[0]){
        if(portals[0].complete){
            if(level<levels.length-1){level++; updateMap(); resetCam(); eeTextEnabled = false;}else{
                background(0, 0, 0);fill(255); textSize(20); transparence = 0;
                text("CONGRATULATIONS\nYou have finished all the levels\nin this game with " + floor(deaths / 100) + " deaths...\nFor now...\nI will add more lvls, mechanics \nand blocks. Maybe\n\n Credits in code\n \n Time spent:" + timer + "s",200,200);}
                textSize(9);
                eeTextEnabled = false;
        }
    }
    if (teleporterIns[0] && teleporterOuts[0]) {
        if (teleporterIns[0].complete === true) {
            teleporterIns[0].complete = false;
            player.x = teleporterOuts[0].x;
            player.y = teleporterOuts[0].y;
            
            teleporterOuts[0].isOff = false;
        }
        if (teleporterOuts[0].complete === true) {
            teleporterOuts[0].complete = false;
            player.x = teleporterIns[0].x;
            player.y = teleporterIns[0].y;
            
            teleporterIns[0].isOff = false;
        }
    }
    if (teleporterIns2[0] && teleporterOuts2[0]) {
        if (teleporterIns2[0].complete === true) {
            teleporterIns2[0].complete = false;
            player.x = teleporterOuts2[0].x;
            player.y = teleporterOuts2[0].y;
            
            teleporterOuts2[0].isOff = false;
        }
        if (teleporterOuts2[0].complete === true) {
            teleporterOuts2[0].complete = false;
            player.x = teleporterIns2[0].x;
            player.y = teleporterIns2[0].y;
            
            teleporterIns2[0].isOff = false;
        }
    }
    for (var i = 0; i < switches.length; i++) {
        for (var j = 0; j < switchBlocks.length; j++) {
            if (switches[i].blueOpen === true) {
                if (switchBlocks[j].type === "blue") {
                    switchBlocks[j].melting = true;
                    switchBlocks[j].solid = false;
                }
            }
            if (switches[i].redOpen === true) {
                if (switchBlocks[j].type === "red") {
                    switchBlocks[j].melting = true;
                    switchBlocks[j].solid = false;
                }
            }
        }
    }
    for(var i =0; i < blocks.length; i++) {
        if (blocks[i].type === "easterEggJumpy") {
            if (player.x <= blocks[i].x + blocks[i].w && player.x >= blocks[i].x - (blocks[i].w / 2) && player.y <= blocks[i].y && (player.y + playerSize[1]) >= blocks[i].y) {
                eeTextEnabled = true;
                    
            }    
        }
    }
    for(var i =0; i < blocks.length; i++) {
        if (blocks[i].type === "easterEgg") {
            if (player.x <= blocks[i].x + blocks[i].w && player.x >= blocks[i].x - (blocks[i].w / 2) && player.y <= blocks[i].y && (player.y + playerSize[1]) >= blocks[i].y) {
                eeTextEnabled = true;
                    
            }    
        }
    }
    if (eeTextEnabled) {
        textSize(30);
        fill(255);
        text("Pls keep the \n easter egg a \n secret", 200, 200);
        fill(0);
    }
    
    rect(0, 400 - grid, 400, grid);
    if (player.dead) {
        deaths += 1;
    }
    if (player.deadTimer < 100) {
        textSize(20);
        fill(255, 0, 0);
        text("Deaths: " + floor(deaths / 100), 50, 385);
    }
    
    text("Time spent: " + timer + "s", 320, 385);
    text("Level: " + (level + 1) + "/" + (levels.length), 173, 385);
    fill(255, 255, 255);
    
    
    //@transparency
    {
    fill(255,255,255,transparence);
    noStroke();
    rect(0,0,width,height);
    fill(255,0,0,redTrans);
    rect(0,0,width,height);
    transparence -=3;
    redTrans-=3;
    transparence=constrain(transparence,0,255);
    redTrans = constrain(redTrans,0,255);
    }
    //background(255);

};

var drawStartScene = function() {
    currentScene = 1;
    background(200, 200, 200);
    startButton.draw();
    charButton.draw();
};

var drawCharScene = function() {
    currentScene = 2;
    background(200, 200, 200);
    for(var i = 0; i < 3; i++) {
        for(var j = 0; j < 3; j++) {
            fill(255);
            rect(i * 130 + 20, j * 130 + 20, 100, 100);
            
        }
    }
    fill(255, 0, 0);
    text("Coming soon! \nI'm so frustrated with this, \nnothing works!", 200, 200);
    //rainbowC.draw(157, 200, player.w, player.h, "rainbow");
    backButton.draw();
};










updateMap();
var cam = new Camera(player.x,player.y);
var draw = function() {
    drawStartScene();
    /*
    var timer = floor(frameCount / 60);
    background(200);
    pushMatrix();
    cam.view(player);
    textSize(20);
    if (level === 0) {
        fill(0, 0, 0);
        textSize(20);
        text("This is ice, \nit melts really fast.\n\t ", 450, 361);
        text("This is a trampoline, \nit makes you bounce.\n\t ", 606, 276);
        text("This is a \n spike, \ndo not touch.\n\t     ", 239, 315);
        text("This is lava, \ndo not touch.\n\t ", 100, 325);
        textSize(10);
        text("This is death, \ndo not touch.\n\t ", 280, 191);
        text("This is a cannon, \nshoots dangerous stuff.\n\t ", 100, 191);
        textSize(15);
        text("This block makes you \nmove in the \ndirection it is facing\n", 264, 443);
    }
    if(level === 3) {
        fill(0, 0, 0);
        textSize(15);
        text("Sometimes \nyou\n just have to \nrisk it...", 107, 399);
        textSize(26);
        fill(97, 97, 97);
        text("It's not \nimpossible...", 323, 317);
        textSize(15);
        fill(150, 150, 150);
        text("Dash!!", 182, 467);
    }
    if (level === 6) {
        fill(140, 127, 51);
        text("Yellow honey blocks \nsimulate \nsun gravity", 105, 296);
        fill(13, 97, 4);
        text("Green jump boost blocks \nsimulate \nmoon gravity", 152, 200);
    }
    if (level === 7) {
        fill(0, 0, 0);
        text("More gravity\n blocks added", 188, 372);
    }
    if (level === 8) {
        fill(0, 0, 0);
        text("Free level!!!", 470, 372);
    }
    if (level === 9) {
        fill(0, 0, 0);
        text("Yay! \nI made \nmoving cannons!", 136, 248);
    }
    if (level === 10) {
        fill(0, 0, 0);
        text("Fake blocks are involved...", 258, 131);
    }
    if (level === 11) {
        fill(0);
        textSize(39);
        text("Portals!!", 200, 393);
    }
    if(level === 12) {
        fill(0);
        textSize(15);
        text("This is a fan-suggested level", 230, 410);
        text("Level suggested by: Anonymous", 230, 400 + grid);
        text("Predators stun you \nwhen you collide \nwith them", 400, 250);
        text("Predators \nstun you \nwhen you collide \nwith them", 60, 225);
    }
    
    
    applyGame();
    popMatrix();
    player.healthBar();
    if(player.deadTimer>100){updateMap(); resetCam();}
    if(portals[0]){
        if(portals[0].complete){
            if(level<levels.length-1){level++; updateMap(); resetCam(); eeTextEnabled = false;}else{
                background(0, 0, 0);fill(255); textSize(20); transparence = 0;
                text("CONGRATULATIONS\nYou have finished all the levels\nin this game with " + floor(deaths / 100) + " deaths...\nFor now...\nI will add more lvls, mechanics \nand blocks. Maybe\n\n Credits in code\n \n Time spent:" + timer + "s",200,200);}
                textSize(9);
                eeTextEnabled = false;
        }
    }
    if (teleporterIns[0] && teleporterOuts[0]) {
        if (teleporterIns[0].complete === true) {
            teleporterIns[0].complete = false;
            player.x = teleporterOuts[0].x;
            player.y = teleporterOuts[0].y;
            
            teleporterOuts[0].isOff = false;
        }
        if (teleporterOuts[0].complete === true) {
            teleporterOuts[0].complete = false;
            player.x = teleporterIns[0].x;
            player.y = teleporterIns[0].y;
            
            teleporterIns[0].isOff = false;
        }
    }
    if (teleporterIns2[0] && teleporterOuts2[0]) {
        if (teleporterIns2[0].complete === true) {
            teleporterIns2[0].complete = false;
            player.x = teleporterOuts2[0].x;
            player.y = teleporterOuts2[0].y;
            
            teleporterOuts2[0].isOff = false;
        }
        if (teleporterOuts2[0].complete === true) {
            teleporterOuts2[0].complete = false;
            player.x = teleporterIns2[0].x;
            player.y = teleporterIns2[0].y;
            
            teleporterIns2[0].isOff = false;
        }
    }
    for (var i = 0; i < switches.length; i++) {
        for (var j = 0; j < switchBlocks.length; j++) {
            if (switches[i].blueOpen === true) {
                if (switchBlocks[j].type === "blue") {
                    switchBlocks[j].melting = true;
                    switchBlocks[j].solid = false;
                }
            }
            if (switches[i].redOpen === true) {
                if (switchBlocks[j].type === "red") {
                    switchBlocks[j].melting = true;
                    switchBlocks[j].solid = false;
                }
            }
        }
    }
    for(var i =0; i < blocks.length; i++) {
        if (blocks[i].type === "easterEggJumpy") {
            if (player.x <= blocks[i].x + blocks[i].w && player.x >= blocks[i].x - (blocks[i].w / 2) && player.y <= blocks[i].y && (player.y + playerSize[1]) >= blocks[i].y) {
                eeTextEnabled = true;
                    
            }    
        }
    }
    if (eeTextEnabled) {
        textSize(30);
        fill(255);
        text("Pls keep the \n easter egg a \n secret", 200, 200);
        fill(0);
    }
    
    rect(0, 400 - grid, 400, grid);
    if (player.dead) {
        deaths += 1;
    }
    if (player.deadTimer < 100) {
        textSize(20);
        fill(255, 0, 0);
        text("Deaths: " + floor(deaths / 100), 50, 385);
    }
    
    text("Time spent: " + timer + "s", 320, 385);
    text("Level: " + (level + 1) + "/" + (levels.length), 173, 385);
    fill(255, 255, 255);
    
    
//@transparency
{
fill(255,255,255,transparence);
noStroke();
rect(0,0,width,height);
fill(255,0,0,redTrans);
rect(0,0,width,height);
transparence -=3;
redTrans-=3;
transparence=constrain(transparence,0,255);
redTrans = constrain(redTrans,0,255);
}
//background(255);
*/

    mouseClicked = function() {
        if(currentScene === 1) {
            if(mouseX > (startButton.x - startButton.w / 2) && mouseX < (startButton.x + startButton.w / 2) && mouseY > (startButton.y - startButton.h / 2) && mouseY < (startButton.y + startButton.h / 2)) {
                gamePlay = true;
            }
            if(mouseX > (charButton.x - charButton.w / 2) && mouseX < (charButton.x + charButton.w / 2) && mouseY > (charButton.y - charButton.h / 2) && mouseY < (charButton.y + charButton.h / 2)) {
                charStart = true;
            }
        
        }
        if(currentScene === 2) {
            if(mouseX > (backButton.x - backButton.w / 2) && mouseX < (backButton.x + backButton.w / 2) && mouseY > (backButton.y - backButton.h / 2) && mouseY < (backButton.y + backButton.h / 2)) {
                startStart = true;
            }
            
        }
        
    };


    if (gamePlay === true) {
        drawGameScene();
    }
    if (charStart === true) {
        drawCharScene();
    }
    if (startStart === true) {
        drawStartScene();
        startStart = false;
        charStart = false;
        gamePlay = false;
    }
};
























    }};

    // Get the canvas that Processing-js will use
    var canvas = document.getElementById("mycanvas"); 
    // Pass the function sketchProc (defined in myCode.js) to Processing's constructor.
    var processingInstance = new Processing(canvas, sketchProc); 
 </script>

</html>
