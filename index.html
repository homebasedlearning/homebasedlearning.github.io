<!DOCTYPE html>
<!-- This is based on DillingerLee's great template here:
https://github.com/Team-Code/KA_Offline -->
<html> 
 <head>
    <title>Game if you are bored</title> 
    <style>
        #header {
            border-bottom: 1px solid;
        	text-align: center;
        }
        #header:hover {
            background-color: gray;
        }
    </style>
</head>
 <body>
    <div id = "header">
    <h2>Game for HBL</h2>
    </div>
    <p><span style = "color: red; font-weight: bold;">Pls click on the canvas to start the game.</span> Also the game is laggy. Btw I've been coding this game for a few days. I'm still actively adding levels to it. You can also 'inspect element' to see the game code (hopefully)</p>
	 <p style = "font-size: 2em; text-align: center; color: red; font-weight: bold;">Use ARROW KEYS to move, so you can't play this game if you are playing on a phone.</p>	 
    <p align="center"> 
	<!--This draws the Canvas on the webpage -->
      <canvas id="mycanvas"></canvas> 
    </p>
    <p>-Made by Javier</p>
 </body>
 
 <!-- Run all the JavaScript stuff -->
 <!-- Include the processing.js library -->
 <!-- See https://khanacademy.zendesk.com/hc/en-us/articles/202260404-What-parts-of-ProcessingJS-does-Khan-Academy-support- for differences -->
 <script src="https://cdn.jsdelivr.net/processing.js/1.4.8/processing.min.js"></script> 
 
 <script>
    var sketchProc = function(processingInstance) {
     with (processingInstance) {
        size(400, 400); 
        frameRate(60);



/*
This game used Jacob's "Game Template" as a base and starting point
Huge thanks to Jacob for his "Game Template" found here:
https://www.khanacademy.org/computer-programming/game-template/4920704444923904
*/


var playerSize = [20,20];//the size of the player
var pJumpHeight=8;
var playerColor = color(255,0,0);
var grid = 30;


/* 
Btw Jacob's less strict on credits so it's fine to take away this line as there is already the same credits above
*/
/***********vvv ADD YOUR LEVELS HERE vvv***********/
var levels = [
    //Replace this with the code for your level.
    //You can add as many as you want. just put them one after the other.
       [
"                             ",
"                             ",
"                             ",
"                             ",
"                        %    ",
"           b                 ",
"           b                 ",
"   %     d b                 ",
" bbbbbbbbbbb                 ",
"           b                 ",
"           b         b       ",
"           b         b       ",
"   #    A  b         bbAb    ",
"                     b### b  ",
"            _ _ _ _  b###    ",
" P          ########Mb###@b  ",
"bbbbbbbbmmbbbbbbbbbbbbbbbbAAA",

],
    [
"                   ",
"                   ",
"                   ",
"                   ",
"                   ",
"                   ",
"                   ",
"   b               ",
"  b     &        b ",
" b  m   bbb__%   b ",
" bb              b ",
"    b            b ",
"    b##M##       b ",
"   b######AAAA@AAb ",
"   b##########b#b  ",
"  Pd############b##",
"bbbbbbbbbbbbbbbbbbbb",

],
[
"                   ",
"                   ",
"                   ",
"                   ",
"                   #",
"                   #",
"                   #",
"                   #",
"                   #",
"                   #",
"    o   m#b        #",
"    b   b#b        #",
"    b@  b bM_ _ _  #",
"    bbbbb%bb#b#b#b #",
"                  M#",
" Pdb&&&&&&&b% % %bb#",
"bbbbbbbbbbbbbbbbbbbb",

],
[
"                   ",
"                   ",
"                   ",
"#            b     ",
"#            b     ",
"#            b     ",
"#  bbbb      b     ",
"## %%%%b     b     ",
"###b   b     b & b ",
"###  b b     b     ",
"###@ b b     b & b ",
"#bob b b     b     ",
"##   bM      b & b ",
"##   bbob    b     ",
"##    bbbbb  b & b ",
"##Pd   ####  b     ",
"bbbbbbbbbbbAobbbbbbb",

],
[
"             #bdddd",
"  bb##b##b   #b    ",
"Pd  bb bb b  #b    ",
"b   ###    b #b    ",
"#   b   b    #b    ",
"#     bbbbbbb#b    ",
"# b bb       b#    ",
"# b#bb        @    ",
"#  b   bb#b##bbbbb ",
"#                  ",
"# bbbbbbb##b##b    ",
"#       bbbbbbb    ",
"#M      #          ",
"bbbbbbbb b b b     ",
"         b####     ",
"     A   b####ooooo",
"bbbbbbbbbbbbbbbbbbb",

],
[
"P_ _ _ _ _ _ _ _ _ _",
"b                   ",
"_ _ _ _ _ _ _ _ _ _ ",
"ddddddddddddddddd  d",
"                    ",
"                   d",
"_ _ _ _ _ _ _ _ _  d",
"d#ddddddddddddd  ddd",
"               _ _ _",
" odddddddddddd  MMMM",
"@                   ",
"b                  ",
"                   ",
"  b                ",
"                   ",
"AAAAAAAAAAAAAAAAAAA",
"bbbbbbbbbbbbbbbbbbbb",

],
[
"                   ",
"          s        ",
"          b        ",
"          b        ",
"          b        ",
"          b        ",
"          b ddddddd",
"        jbb        ",
"       M  b        ",
"          b _ _ _ _s",
"      M   b ########",
"    _    Mb ########",
"   b#     b ########",
"  sb#   M b ########",
"  b###    b ########",
" Pd####M  bjMMMM@MMM",
"bbbbbbbbbbbbbbbbbbbb",

],
[
"          b        ",
" oooooooo b        ",
"       b  b        ",
"       b bb        ",
"mmmmdm b  b        ",
"       bb b        ",
"       b  b        ",
" odoooob bb        ",
"       b    b      ",
"      @b           ",
"mmmmmdob n         ",
"            b      ",
"                   ",
"         g         ",
"  sb b b###########",
" Pd################",
"bbbbbbbbbbbbbbbbbbbb",

],
[
"                   ",
"                   ",
"                   ",
"                   ",
"                   ",
"                   ",
"                   ",
"                   ",
"                   ",
"                   ",
"                   ",
"                   ",
"                   ",
"                   ",
"              Pd   ",
"    @         mm   ",
"mmmmmmmmmmmmmbbbmmd",

],
[
"#                  ",
"#                  ",
"#       d#         ",
"#       dbbbbbbbbbbb",
"#       dM         ",
"#       dMbb#b#bb  b",
"#       dM  b b    ",
"#       dM#        ",
"#       dM#        ",
"#       dM#        ",
"#bc c cbdM#        ",
"#        M#@      #",
"#  _ _ _ Mbbmmmmmmm",
"b b######M         ",
"b b######M         ",
" Pd######M         ",
"bbbbbbbbbbbbbbbbbbb",

],
    
    ];
/******* vvv DON'T TOUCH THOSE! vvv ******/
var level = 0;
var keys = [];
var level_h = 800;
var level_w = 800;
var transparence = 0;
var redTrans = 0;
var cam;
//@key interaction
keyPressed = function(){keys[keyCode]=true;};
keyReleased = function(){ keys[keyCode]=false; };

var polygonCollide = function(shape1, shape2) {

    var isBetween = function(c, a, b) {
        return (a - c) * (b - c) <= 0;
    };
    
    /* Do ranges a and b overlap? */
    var overlap = function(a, b) {
        return isBetween(b.min, a.min, a.max) || isBetween(a.min, b.min, b.max);
    };
    
    /*
     * Project shape onto axis.  Simply
     * compute dot products between the
     * shape's vertices and the axis, and
     * keep track of the min and max values.
     */
    var project = function(shape, axis) {
        var mn = Infinity;
        var mx = -Infinity;
        for (var i = 0; i < shape.length; i++) {
            var dot = shape[i].x*axis.x + shape[i].y*axis.y;
            mx = max(mx, dot);
            mn = min(mn, dot);
        }
        return { min: mn, max: mx };
    };
    
    /* Compute all projections axes of shape. */
    var getAxes = function(shape) {
        var axes = [];
        for (var i = 0; i < shape.length; i++) {
            var n = (i + 1) % shape.length; 
            /*
             * The edge is simply the delta between i and n.
             * The axis is the edge's normal. And a normal 
             * of (x, y) is either of (y, -x) or (-y, x).
             */
            axes[i] = {
                y: shape[i].x - shape[n].x,
                x: -(shape[i].y - shape[n].y)
            };
        }
        return axes;
    };

    var shapes = [ shape1, shape2 ];
    for (var s = 0; s < shapes.length; s++) {
        var axes = getAxes(shapes[s]);
        for (var i = 0; i < axes.length; i++) {
            var axis = axes[i];
            /* Project both shapes onto this axis */
            var p1  = project(shape1, axis);
            var p2  = project(shape2, axis);
            if (! overlap(p1, p2)) {
                /* The two shapes cannot overlap */
                return false;
            }
        }
    }
    return true;  /* they overlap */
};//for triangular collisions


var Camera = function(x,y){
    this.x=x; this.y=y; this.w=width; this.h = height;
    this.view = function(plyer){
        this.x=plyer.x;
        this.y=plyer.y;
        
        this.x = constrain(this.x,this.w/2,level_w-this.w/2);
        this.y = constrain(this.y,this.h/2,level_h-this.h/2);
        translate(200-this.x,200-this.y);
    };
};

var view = function(obj){
    return obj.x+200-cam.x<width&&obj.x+200-cam.x>-obj.w&&
    obj.y+200-cam.y<height&&obj.y+200-cam.y>-obj.h;
};


var collide=function(obj1,obj2){ 
    return obj1.x<obj2.x+obj2.w&&obj1.x+obj1.w>obj2.x&& 
    obj1.y<obj2.y+obj2.h&&obj1.y+obj1.h>obj2.y;
};

var Player = function(x,y,w,h){
    this.x=x; this.y=y;
    this.w=w; this.h=h; 
    this.speed = 0.5;
    this.yvel = 0; this.xvel = 0;
    this.gravity = 0.3; this.JH = pJumpHeight;
    this.falling = false; this.speedLimit = 5;
    this.fallLimit = 8; this.health = 100;
    this.dir = 0; this.color = playerColor;//art stuff
    this.dead = false; this.deadTimer = 0; 
    this.update = function(blocks){
        this.sight = this.w/4;//calculate the offset of the face based on the width of the player.
        
        if(!this.dead){//moving
        if(keys[UP]&&!this.falling){ this.yvel=-this.JH;}
        if(keys[RIGHT]){this.xvel+=this.speed; this.dir+=this.speed;}
        if(keys[LEFT]){ this.xvel-=this.speed; this.dir-=this.speed;} 
        }
        if(!keys[RIGHT]&&!keys[LEFT]){
        if(this.dir>0){this.dir-=this.speed;}
        if(this.dir<0){this.dir+=this.speed;}
        if(this.xvel>0){this.xvel-=this.speed;}
        if(this.xvel<0){this.xvel+=this.speed;}
        }
        this.dir = constrain(this.dir,-this.sight,this.sight);
        this.xvel=constrain(this.xvel,-this.speedLimit,this.speedLimit);
        if(this.yvel>this.fallLimit){ this.yvel=this.fallLimit; }
        this.x = constrain(this.x,0,level_w-this.w);
        this.x+=this.xvel;
        this.applyCollision(blocks,this.xvel,0); // apply speed and collisions
        this.falling=true;
        this.y+=this.yvel;
        this.applyCollision(blocks,0,this.yvel);
        this.yvel+=this.gravity;
        
        if(this.health<=0){
            this.dead = true;
        }
        if(this.dead){
            this.deadTimer++;
        }
    };
    this.draw = function() {
        noStroke();
        var d = (this.dir/this.w)*15;
    fill(this.color);
    rect(this.x,this.y,this.w,this.h,(this.w+this.h)/20);
    this.eyeSize = (this.w+this.h)/10;
    fill(0);
    ellipse(d+this.x+this.w/3,this.y+this.h/3,this.eyeSize,this.eyeSize);
    ellipse(d+this.x+this.w*2/3,this.y+this.h/3,this.eyeSize,this.eyeSize);

    noFill();
    stroke(0);
    strokeWeight(1);
    
    };
    this.applyCollision=function(obj,velx,vely){
    for(var i=0; i<obj.length; i++){
        if(collide(this,obj[i])&&obj[i].solid){ // handle collisions
            if(obj[i].type==="ice"){obj[i].melting = true;}//make the ice blocks start melting
            if(vely>0){ this.yvel=0; this.falling=false; this.y=obj[i].y-this.h; }
            if(vely<0){ this.yvel=0; this.falling=true; this.y=obj[i].y+obj[i].h; }
            if(velx<0){ this.xvel=0; this.x=obj[i].x+obj[i].w; }
            if(velx>0){ this.xvel=0; this.x=obj[i].x-this.w; }
        }
    }
};
this.healthBar = function(){
    textSize(14);
    fill(255);
    rect(20,20,360,15);
    fill(255, 0, 0);
    rect(20,20,this.health * 3.6,15);
    fill(0);
    textAlign(CENTER,CENTER);
    text("Health "+max(0,round(this.health))+"%",208,20+15/2);
    this.health = constrain(this.health,0,100);
};
};
var player = new Player(200,100,playerSize[0],playerSize[1]);

//@blocks
var Block = function(x,y,w,h,type,i){
    this.x=x; this.y=y; this.w=w; this.h=h; this.isImage = i;
    this.type = type; this.melting = false;
    this.solid = true; this.op = 255;
    this.fast = false; this.idk = 255;
    this.oppFast = false;
    this.slow = false;
    this.draw = function() {
        if(view(this)){
            switch(this.type){
                case "moving":
                    fill(77, 77, 77);
                    rect(this.x, this.y, this.w, this.h);
                    fill(163, 163, 163);
                    pushMatrix();
                    translate(18, 16);
                    triangle(this.x - 10, this.y + 10, this.x - 10, this.y - 10, this.x + 10, this.y);   
                    popMatrix();
                break;
                case "op-moving":
                    fill(77, 77, 77);
                    rect(this.x, this.y, this.w, this.h);
                    fill(163, 163, 163);
                    pushMatrix();
                    translate(13, 16);
                    triangle(this.x - 10, this.y + 0, this.x + 10, this.y - 10, this.x + 10, this.y + 10);   
                    popMatrix();
                break;
                case "solid":
                    noStroke(); fill(163, 163, 163);
                    rect(this.x,this.y,this.w,this.h);
                break;
                case "ice":
                    strokeWeight(2); stroke(255,255,255,this.op); fill(150, 207, 245,this.op);
                    rect(this.x+1,this.y+1,this.w-2,this.h-2);
                break;
                case "slow":
                    noStroke(); fill(222, 206, 57);
                    rect(this.x, this.y, this.w, this.h);
                break;
                case "jumpy":
                    noStroke(); fill(68, 255, 51);
                    rect(this.x, this.y, this.w, this.h);
                break;
                case "gravity":
                    noStroke(); fill(255, 119, 0);
                    rect(this.x, this.y, this.w, this.h);
                break;
                case "normal-grav":
                    noStroke(); fill(0, 60, 255);
                    rect(this.x, this.y, this.w, this.h);
                break;
            }
        }
    };
    this.update = function(){
        if(this.type==="ice"){
            if(this.melting){
                this.op-=50;
            }
            if(this.op<50){
                this.solid = false;
            }
            if(this.op<-2000){
                this.op=255;
                this.melting = false;
                this.solid = true;
            }
            
        }
       if (this.type === "moving") {
            
            if (player.x <= this.x + this.w && player.x >= this.x - (this.w / 2) && player.y <= this.y && (player.y + playerSize[1]) >= this.y) {
                    this.fast = true;    
            }
            else {
                this.fast = false;   
            }
            if (this.fast === true) {
                player.x += 5;
            }
            if (this.idk === 255) {
                this.fast = false;    
            }
            
            
        }
        if (this.type === "op-moving") {
            
            if (player.x <= this.x + this.w && player.x >= this.x - (this.w / 2) && player.y <= this.y && (player.y + playerSize[1]) >= this.y) {
                    this.oppFast = true;    
            }
            else {
                this.oppFast = false;   
            }
            if (this.oppFast === true) {
                player.x -= 5;
            }
            if (this.idk === 255) {
                this.oppFast = false;    
            }
            
            
        }
        if (this.type === "slow") {
            if (player.x <= this.x + this.w && player.x >= this.x - (this.w / 2) && player.y <= this.y && (player.y + playerSize[1]) >= this.y) {
                player.gravity = 1;
            }
            
        }
        if (this.type === "jumpy") {
            if (player.x <= this.x + this.w && player.x >= this.x - (this.w / 2) && player.y <= this.y && (player.y + playerSize[1]) >= this.y) {
                player.gravity = 0.15;
            }    
        }
        if (this.type === "gravity") {
            if (player.x <= this.x + this.w && player.x >= this.x - (this.w / 2) && player.y <= this.y && (player.y + playerSize[1]) >= this.y) {
                player.gravity = 0.5;
            }    
        }
        if (this.type === "normal-grav") {
            if (player.x <= this.x + this.w && player.x >= this.x - (this.w / 2) && player.y <= this.y && (player.y + playerSize[1]) >= this.y) {
                player.gravity = 0.3;
            }    
        }
        
        
    };
    
};
var blocks = [];
blocks.add = function(x,y,w,h,t){ this.push(new Block(x,y,w,h,t)); };
blocks.apply = function(){
    for(var i=0;i<this.length;i++){
        this[i].draw();
        this[i].update();
    }
};

//@portal
var Goal = function(x,y,radius,i){
    this.x=x; this.y=y; this.w=radius; this.h=radius; this.isImage = i;
    this.timer = 0; this.complete = false; this.color = 0;
    this.draw = function() {
        if(view(this)){
            colorMode(HSB);
            noStroke();
            for(var i=0;i<this.w/2;i+=2){
            fill(255,0,255,i*10);
        ellipse(this.x+this.w/2,this.y+this.h/2,this.w-i*2,this.h-i*2);
        }
        noFill();
        strokeWeight(2);
        for(var i=0;i<this.w/2;i+=2){
            this.opacity = (sin(i*frameCount)*70);
            stroke(frameCount%255, 255,255,this.opacity);
        ellipse(this.x+this.w/2,this.y+this.h/2,this.w-i*2,this.h-i*2);
        }
        colorMode(RGB);
        }
    };
    this.update = function(){
        
        if(collide(this,player)){
            transparence+=5;
        }
        if(transparence>=250){
            this.complete = true;
        }
        
    };
};
var portals = [];
portals.add=function(x,y,r){ this.push( new Goal(x,y,r));};
portals.apply = function(){
    for(var i=0;i<this.length;i++){
        this[i].draw();
        this[i].update();
    }
};

//@lava
var Lava = function(x,y,s,i){
    this.x=x; this.y=y; this.w=s; this.h=s;
    this.s = (s/3); this.isImage = i;
    this.draw = function() {
        if(view(this)){
        noStroke();
        for(var x=0;x<this.w;x+=this.s){
            for(var y=0;y<this.h;y+=this.s){
                fill(random(100,200),0,0);
                rect(this.x+x,this.y+y,this.s,this.s);
            }
        }
        }
    };
    this.update = function(){
        if(collide(this,player)){
            player.health-=2;
            redTrans = 80;
            
        }
    };
};
var lava = [];
lava.add = function(x,y,s){ this.push(new Lava(x,y,s)); };
lava.apply = function(){
    for(var i=0;i<this.length;i++){
        this[i].draw();
        this[i].update();
    }};
//@deathBlock
var deathBlock = function(x,y,s,i){
    this.x=x; this.y=y; this.w=s; this.h=s;
    this.s = (s/3); this.isImage = i;
    this.draw = function() {
        if(view(this)){
        noStroke();
        for(var x=0;x<this.w;x+=this.s){
            for(var y=0;y<this.h;y+=this.s){
                fill(random(0, 69), random(0, 69), random(0, 69));
                rect(this.x+x,this.y+y,this.s,this.s);
            }
        }
        }
    };
    this.update = function(){
        if(collide(this,player)){
            player.health = 0;
            redTrans = 80;
            
        }
    };
};
var DeathBlock = [];
DeathBlock.add = function(x,y,s){ this.push(new deathBlock(x,y,s)); };
DeathBlock.apply = function(){
    for(var i=0;i<this.length;i++){
        this[i].draw();
        this[i].update();
    }};
//@ghostBlock
var ghostBlock = function(x,y,s,i){
    this.x=x; this.y=y; this.w=s; this.h=s;
    this.s=s; this.isImage = i;
    this.draw = function() {
        if(view(this)){
        noStroke();
        for(var x=0;x<this.w;x+=this.s){
            for(var y=0;y<this.h;y+=this.s){
                fill(209, 209, 209);
                rect(this.x+x,this.y+y,this.s,this.s);
            }
        }
        }
    };
    
};
var GhostBlock = [];
GhostBlock.add = function(x,y,s){ this.push(new ghostBlock(x,y,s)); };
GhostBlock.apply = function(){
    for(var i=0;i<this.length;i++){
        this[i].draw();
    }};
//@spikes
var Spike = function(x,y,w,h,i){
    this.x=x; this.y=y; this.w=w; this.h=h;
    this.isImage = i;
    this.draw = function() {
        if(view(this)){
            noStroke();
        fill(120);
        triangle(this.x+this.w/2,this.y,this.x,this.y+this.h,this.x+this.w,this.y+this.h);
        }
        
        
    };
    this.update = function(){
        if(polygonCollide([
            {x:player.x,y:player.y},
            {x:player.x+player.w,y:player.y},
            {x:player.x+player.w,y:player.y+player.h},
            {x:player.x,y:player.y+player.h}],//the player
            [{x:this.x+this.w/2,y:this.y},
            {x:this.x,y:this.y+this.h},
            {x:this.x+this.w,y:this.y+this.h}])){
        player.yvel=-player.JH;
        player.health-=5;
        redTrans = 80;//red flash
        }
    };
    
};
var spikes = [];
spikes.add=function(x,y,s){ this.push( new Spike(x,y,s,s)); };
spikes.apply = function(){
    for(var i=0;i<spikes.length;i++){
        this[i].draw();
        this[i].update();
    }
};

//@jumpBlocks
var JumpBlock = function(x,y,w,h,i){
    this.x=x; this.y=y; this.w=w; this.h=h; this.isImage = i;
    this.draw = function() {
        if(view(this)){
            noStroke();
            fill(255, 71, 169);
            rect(this.x,this.y,this.w,this.h);
        }
    };
    this.update = function(){
        if(collide(this,player)){
            player.yvel=-player.JH*1.3;
        }
        
    };
    
};
var jumpBlocks = [];
jumpBlocks.add = function(x,y,w,h){ this.push( new JumpBlock(x,y,w,h) );  };
jumpBlocks.apply = function(){
    for(var i=0;i<this.length;i++){
        this[i].draw();
        this[i].update();
    }
};
    
var Bullet = function(x,y,s,angle){
    this.x=x; this.y=y; this.w=s; this.h=s;
    this.deleted = false; this.angle = angle;
    this.draw = function() {
        if(!this.deleted){
        noStroke();
        fill(50);
        ellipseMode(CORNER);
        ellipse(this.x,this.y,this.w,this.h);
        ellipseMode(CENTER);
        }
    };
    this.update = function(){
        this.x+=cos(this.angle)*2;
        this.y+=sin(this.angle)*2;
        if(collide(this,player)&&!this.deleted&&!player.dead){
            this.deleted = true;
            player.health -=10;
            redTrans=80;
        }
        for(var i=0;i<blocks.length;i++){
        if(collide(this,blocks[i])&&!this.deleted){
            this.deleted = true;
        }
        }
        
    };
};
var bullets = [];
bullets.add = function(x,y,angle){
    this.push( new Bullet(x,y,5,angle));
};
bullets.apply = function(){
    for(var i=0;i<this.length;i++){
        bullets[i].draw();
        bullets[i].update();
        if(bullets[i].deleted){
            bullets.splice(i,1);
        }
    }
};
var Cannon = function(x,y,w,h){
    this.x=x; this.y=y; this.w=w; this.h=h;
    this.angle = atan2(this.x-player.x,player.y-this.y);
    this.bullets = [];
    this.draw = function() {
        if(view(this)){
        noStroke();
        fill(80);
        ellipse(this.x+this.w/2,this.y+this.h/2,this.w*3/5,this.h*3/5);
        pushMatrix();
        translate(this.x+this.w/2,this.y+this.h/2);
        rotate(this.angle);
        rect(-5,5,this.w/3,10);
        popMatrix();
        }
        
    };
    this.update = function(){
        this.angle = atan2(this.x-player.x,player.y-this.y);
        if((frameCount%100)===99){
            bullets.add(this.x+this.w/2,this.y+this.h/2,this.angle+90);
        }
        
    };
    
};
var cannons = [];
cannons.add = function(x,y,s){this.push( new Cannon(x,y,s,s));};
cannons.apply = function(){
    for(var i=0;i<this.length;i++){
        this[i].draw();
        this[i].update();
    }
};

var Monster=function(x,y,w,h){
    this.x=x; this.y=y; this.w=w; this.h=h;
    this.dead=false; // is the monster "dead"?
    this.xvel=1; // monster's speed
    this.angle=0; // the monster's eye's angle
this.draw= function() {
    if(view(this)&&!this.dead){
        // draw the monster
        fill(23, 130, 57);
        noStroke();
        rect(this.x,this.y,this.w,this.h,Math.abs(cos(frameCount*2))*10); // main body
        
        fill(255, 255, 255);
        stroke(0);
        ellipse(this.x+this.w/2,this.y+this.h/2,this.w/2,this.h/2); // the white of the eye
        // the pupil
        pushMatrix();
        translate(this.x+this.w/2,this.y+this.h/2);
        rotate(this.angle+40);
        fill(0, 0, 0);
        ellipseMode(CORNER);
        ellipse(0,0,this.w/5,this.h/5);
        ellipseMode(CENTER);
        popMatrix();
    }
};
this.update = function(){
    if(!this.dead){
    this.angle = atan2(this.x-player.x,player.y-this.y);//make the angle point to the player
    this.x+=this.xvel;
    for(var i=0;i<blocks.length;i++){
        if(collide(this, blocks[i])){
            this.xvel=-this.xvel;
        }
    }
    if(collide(this, player)){
        if(!player.falling&&!this.dead&&!player.dead){
                player.health-=5;
                redTrans = 80;
        }else if(player.yvel>0&&player.falling){
                this.dead=true; // the monster is "dead"
                player.yvel=-player.JH; // make the player hop 
                
            }
    }
    }
};
};
var monsters=[];
monsters.add=function(x,y,w,h){ this.push(new Monster(x,y,w,h)); };
monsters.apply=function(){
    for(var i=0; i<this.length; i++){
        this[i].update();
        this[i].draw();
        if(this[i].dead){this.splice(i,1);}
    }
};
var moveCannon = function(x,y,w,h){
    this.x=x; this.y=y; this.w=w; this.h=h;
    this.angle = atan2(this.x-player.x,player.y-this.y);
    this.bullets = []; this.dead = false;
    this.xvel = 1;
    this.draw = function() {
        if(view(this)){
        noStroke();
        fill(80);
        ellipse(this.x+this.w/2,this.y+this.h/2,this.w*3/5,this.h*3/5);
        pushMatrix();
        translate(this.x+this.w/2,this.y+this.h/2);
        rotate(this.angle);
        rect(-5,5,this.w/3,10);
        popMatrix();
        }
        
    };
    this.update = function(){
        this.angle = atan2(this.x-player.x,player.y-this.y);
        if((frameCount%100)===99){
            bullets.add(this.x+this.w/2,this.y+this.h/2,this.angle+90);
        }
        if (!this.dead) {
            this.x += this.xvel;
            
            for(var i=0;i<blocks.length;i++){
                if(collide(this, blocks[i])){
                    this.xvel=-this.xvel;
                }
            }
            if(collide(this, player)){
                if(!player.falling&&!this.dead&&!player.dead){
                        player.health-=5;
                        redTrans = 80;
                }else if(player.yvel>0&&player.falling){
                        this.dead=true; // the monster is "dead"
                        player.yvel=-player.JH; // make the player hop 
                        
                }
            }
        }
    };
    
};
var moveCannons = [];
moveCannons.add = function(x,y,s){this.push( new moveCannon(x,y,s,s));};
moveCannons.apply = function(){
    for(var i=0;i<this.length;i++){
        this[i].draw();
        this[i].update();
        if(this[i].dead){this.splice(i,1);}
    }
};
    
//manage the objects in the game
var objects = [blocks,portals,lava,spikes,jumpBlocks,cannons,bullets, monsters, DeathBlock, GhostBlock, moveCannons];
objects.remove = function(){
    for (var i = 0; i < objects.length; i++) {
        for (var j = 0; j < objects[i].length; j++) {
            objects[i].splice(j, objects[i].length);
        }
    }
};

var updateMap = function(){
    objects.remove();
    for(var col=0; col<levels[level].length; col++){
        var cells = levels[level][col];
        for(var row=0; row<cells.length; row++){
            switch(cells[row]){
                case "b": blocks.add(row*grid,col*grid,grid,grid,"solid",player);
                    break;
                case "@": portals.add(row*grid,col*grid,grid);
                    break;
                case "_": blocks.add(row*grid,col*grid+(grid/3)*2,grid*2,grid/3,"ice");
                    break;
                case "#": lava.add(row*grid,col*grid,grid,grid);
                    break;
                case "P": player = new Player(row*grid-(player.w-grid)/2,col*grid-(player.h-grid)/2,playerSize[0],playerSize[1]);
                    break;
                case "A": spikes.add(row*grid,col*grid,grid,grid);
                    break;
                case "M": jumpBlocks.add(row*grid,col*grid+grid*2/3,grid,grid/3);
                    break;
                case "%": cannons.add(row*grid,col*grid,grid);
                    break;
                case "&": monsters.add(row*grid,col*grid,grid,grid);
                    break;
                case "m": blocks.add(row * grid,col * grid, grid, grid, "moving");
                    break;
                case "d": DeathBlock.add(row * grid, col * grid, grid, grid);
                    break;
                case "o": blocks.add(row * grid, col * grid, grid, grid, "op-moving");
                    break;
                case "s": blocks.add(row * grid, col * grid, grid, grid, "slow");
                    break;
                case "j": blocks.add(row * grid, col * grid, grid, grid, "jumpy");
                    break;
                case "g": blocks.add(row * grid, col * grid, grid, grid, "gravity");
                    break; 
                case "n": blocks.add(row * grid, col * grid, grid, grid, "normal-grav");
                    break; 
                case "c": moveCannons.add(row*grid,col*grid,grid);
                    break;
            }
            level_w = levels[level][col].length * grid;
            level_h = levels[level].length * grid;
        }
    }
};

    
var resetCam = function(){
cam.x=player.x; cam.y=player.y;
};//reset the cam to the player's location.
var applyGame = function(){
    blocks.apply();
    portals.apply();
    if(!player.dead){ player.draw(); }
    lava.apply();
    spikes.apply();
    jumpBlocks.apply();
    monsters.apply();
    bullets.apply();
    cannons.apply();
    DeathBlock.apply();
    moveCannons.apply();
    player.update(blocks);
    
    
};
    


updateMap();
var cam = new Camera(player.x,player.y);
var draw = function() {
    background(200);
    pushMatrix();
    cam.view(player);
    textSize(20);
    if (level === 0) {
        fill(0, 0, 0);
        text("This is ice, \nit melts really fast.\n\t ↓", 450, 361);
        text("This is a trampoline, \nit makes you bounce.\n\t ↓", 606, 276);
        text("This is a \n spike, \ndo not touch.\n\t     ↓", 239, 315);
        text("This is lava, \ndo not touch.\n\t ↓", 100, 325);
        textSize(16);
        text("This is death, \ndo not touch.\n\t ↓", 280, 181);
        text("This is a cannon, \nshoots dangerous stuff.\n\t ↓", 100, 181);
        textSize(15);
        text("This block makes you \nmove in the \ndirection it is facing\n↓", 264, 443);
    }
    if(level === 3) {
        fill(0, 0, 0);
        textSize(15);
        text("Sometimes \nyou\n just have to \nrisk it...", 107, 399);
        textSize(26);
        fill(97, 97, 97);
        text("It's not \nimpossible...", 323, 317);
        textSize(15);
        fill(150, 150, 150);
        text("Dash!!", 182, 467);
    }
    if (level === 6) {
        fill(140, 127, 51);
        text("Yellow honey blocks \nsimulate \nsun gravity", 105, 296);
        fill(13, 97, 4);
        text("Green jump boost blocks \nsimulate \nmoon gravity", 152, 200);
    }
    if (level === 7) {
        fill(0, 0, 0);
        text("More gravity\n blocks added", 188, 372);
    }
    if (level === 8) {
        fill(0, 0, 0);
        text("Free level!!!", 470, 372);
    }
    if (level === 9) {
        fill(0, 0, 0);
        text("Yay! \nI made \nmoving cannons!", 136, 248);
	text("You can also \njump on them \nto kill them!", 136, 120);
    }
    
    applyGame();
    popMatrix();
    player.healthBar();
    if(player.deadTimer>100){updateMap(); resetCam();}
    if(portals[0]){
        if(portals[0].complete){
            if(level<levels.length-1){level++; updateMap(); resetCam();}else{
                background(0, 0, 0);fill(255); textSize(20); transparence = 0;
                text("CONGRATULATIONS\nYou have finished all the levels\nin this game...\nFor now...\nI will add more lvls, mechanics \nand blocks. Maybe\n\n Credits in code",200,200);}
                textSize(9);
                
        }
    }
    
//@transparency
{
fill(255,255,255,transparence);
noStroke();
rect(0,0,width,height);
fill(255,0,0,redTrans);
rect(0,0,width,height);
transparence -=3;
redTrans-=3;
transparence=constrain(transparence,0,255);
redTrans = constrain(redTrans,0,255);
}
//background(255);
};








    }};

    // Get the canvas that Processing-js will use
    var canvas = document.getElementById("mycanvas"); 
    // Pass the function sketchProc (defined in myCode.js) to Processing's constructor.
    var processingInstance = new Processing(canvas, sketchProc); 
 </script>

</html>
